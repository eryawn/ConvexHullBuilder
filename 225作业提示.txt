怎么知道一个点在凸包里
检查连续两个点再连接新点是不是右拐 O(h) 最佳是log2n
上下两包同时找，上面右拐，下面左拐 也是O(h)

二进制搜索上下两包，找到新点的bounds 再连接判断

搜索最好用array

add就用linked

先把array转成linked for upper hull
然后相当于把所有连线先去掉重新找 下边该什么样什么样


design：
hullbuilder里的fields：点集和hull都是linked
add进来一个点加在点集里，因为加点必须是oh，那么每次加进来需要判断点的位置
保证加进来就是在正确的顺序里。

问：addpoints的时候怎么实现oh	linkedlist怎么实现get remove add oh
	能不能把测试标准告诉我们
必须加点一次计算一次，否则加点超过两个以上，再不sort，那只能去gethull里sort了

gethullb：
连线端点判断左右拐确定在上下
通过端点x位置判断再正上下
比如在正上：搜索两端index如果都不在端点，


迭代器做法：进一步看一眼，有点，退一步回来。p，和进两步过的点判断拐向，记录拐向。
如果正确，退出循环，查看另一边。while的条件应该是：拐向正确&&进一步后hasnext


判断上下，判断左右，如果在正上下，那么加入半圈，然后半圈开始迭代。
如果在左右外侧，证明影响端点了。两个半圈都加入，都迭代。
所以需要两个半圈函数。
先写半圈函数
